####1.箭头函数与普通函数的区别

+ 箭头函数不会创建自己的this，它会捕获自己在**定义时**（注意，是定义时，不是调用时）所处的**外层执行环境的`this`**，并继承这个`this`值。所以，箭头函数中`this`的指向在它被定义的时候就已经确定了，之后永远不会改变。箭头函数继承而来的`this`指向永远不变。`.call()`/`.apply()`/`.bind()`方法可以用来动态修改函数执行时`this`的指向，但由于箭头函数的`this`定义时就已经确定且永远不会改变。
+ 箭头函数不能作为构造函数使用。我们先了解一下构造函数的new都做了些什么？简单来说，分为四步： ① JS内部首先会先生成一个对象； ② 再把函数中的this指向该对象； ③ 然后执行构造函数中的语句； ④ 最终返回该对象实例。因为箭头函数没有自己的`this`，它的`this`其实是继承了外层执行环境中的`this`，且`this`指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用`new`调用时会报错！
+ 没有自己的arguments。在箭头函数中访问`arguments`实际上获得的是外层局部（函数）执行环境中的值。
+ 没有原型prototype

#### 2.http

+ Cookie

  服务端生成cookie在响应中通过set-cookie头部告知客户端，客户端得到之后会自动将cookie添加到下一系列的请求头部中。

+ Get& Post

  数据传输方式不同：GET请求通过URL传输数据，而POST的数据通过请求体传输。

  安全性不同：POST的数据因为在请求主体内，所以有一定的安全性保证，而GET的数据在URL中，通过历史记录，缓存很容易查到数据信息。

  数据类型不同：GET只允许 ASCII 字符，而POST无限制

  GET无害： 刷新、后退等浏览器操作GET请求是无害的，POST可能重复提交表单

  特性不同：GET是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），而POST是非安全非幂等

+ Put & Post

  PUT 和POST方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用），而POST方法是非幂等的。

+ keep-alive的优点：

  - 较少的CPU和内存的使用（由于同时打开的连接的减少了）
  - 允许请求和应答的HTTP管线化
  - 降低拥塞控制 （TCP连接减少了）
  - 减少了后续请求的延迟（无需再进行握手）
  - 报告错误无需关闭TCP

+ https

  http 天生明文传输，任何人都可以截获或者伪造，而且无法确定发送和接受方的身份，没有身份验证，无法验证报文的缺失。

  https对http进行加密，确定对方的真实身份。每个秘钥都有一个私有秘钥和公有秘钥，私有秘钥是独有的，一般位于服务器上，用于解密由公有秘钥加密过的信息；公有秘钥是公有的，与服务器交互的每个客户端都可以持有，用公钥加密的信息只能由私有秘钥来解密。

  如果采用对称加密，那么加密后的钥匙传输又会成为问题，所以采用非对称加密，产生一个公钥和一个秘钥，公钥加密的数据只有私钥能够解密，私钥加密的数据只有公钥能够解密，但是rsa算法很慢，所以采用对称加密和非对称加密结合——使用 RSA 的方法将加密算法的对称密钥发送过去，之后就可以使用使用这个密钥，利用对称密钥来通信了。就比如说我将钥匙放进了保险柜，然后将保险柜寄给对方。这样还有一个问题，在使用非对称加密的时候，是要先将服务端的公钥发给客户端的，中间人可以拦截公钥。所以就需要一个公证处来公正，这个公钥确实是服务端的公钥，客户端在收到这个公钥之后去和公证处核对一下，确定身份。

+ Http2 

  + 队头阻塞，浏览器希望同时获得许多资源，http1仅仅能够使用一个连接一个接一个的发送请求，等待响应，如果其中有一个响应出现问题，那么后面的工作都被阻塞，也就是页面的渲染和网络传输都会失去响应。为了解决这个问题，浏览器目前会对单个域名开启6个连接，但是每个连接仍然会受到队头阻塞的影响。
  + 臃肿的消息首部。首部消息不能忽略，却又无法压缩。



#### 性能优化

从用户角度来看，一个是页面加载的很快，另一个是页面使用起来很流畅。因此，对性能优化的探索，我们可以分为页面加载时间跟页面运行效率两个方向来进行研究。

+ 减少HTTP请求（因为一个完整的请求要经过DNS寻址，与服务器建立连接，发送数据，等待服务器响应，接收数据这样一个消耗时间成本和资源成本的复杂的过程。）
  + 雪碧图
  + 合并JS和CSS文件
  + 减少http请求头
  + 配置多个域名和CDN加速
  + 使用缓存（HTTP缓存、浏览器缓存、应用缓存）
  + 优化cookie
+ HTML
  + HTML标签有始终。 减少浏览器的判断时间
  + 减少iframe的使用，因为iframe会增加一条http请求，阻止页面加载，即使内容为空，加载也需要时间
  + 使用css+div代替table布局，去掉格式化控制标签如：strong，b，i等
+ CSS（减少页面的重排和重绘，也就是下面的操作）
  + 改变元素的内外边距
  + 通过JS改变CSS类
  + 通过JS获取DOM元素的位置相关属性（如width/height/left等）
  + CSS伪类激活
  + 滚动滚动条或者改变窗口大小
  + 不要使用@import
+ JS
  + 优化循环（因为是同步的，js解释器会等待循环执行完，计算时间太长会造成卡顿）
  + 减少DOM操作



# Webpack

loader本身就是一个函数

```js
module.exports = function(source) {
  // source 表示我们通过webpack解析出来的源代码
  // 将代码中的a 全部换成b
  // 配置项options可以通过this.query来获得
  return source.replace('a', 'b')
}
```



+ 拆分配置 通过webpack-merge导入smart来将公共的配置和不同环境的配置结合

+ 多入口配置，entry配置成对象，output修改[name]hash值，在plungins中配置多个HtmlWebpackPlugin，需要配置chunk属性

+ 抽离css MiniCssExtractPlugin.loader抽离 然后在optimization中配置minimizer属性，值为[new TerserJSPlugin({}), new OptimizeCSSAssetsPlugin({})]

+ 抽离公共代码

+ module:各个源码文件，因为webpack中一切皆模块，chunk：通过文件的解析分析出的多个模块的合成代码，有点像内存的概念，还没有整体输出，bundle就是我们打包过程中最终的输出文件。

+ 性能优化：

  + 优化构建速度：

    1. 优化babel-loader: loader中['babel-loader?cacheDirectory'] 来开启缓存，include和exclude来明确范围

    2. IgnorePlugin

    3. noParse

    4. happyPack（多进程打包）：利用多核CPU提升构建速度 new happyPack({id: 'babel', loaders: ['babel-loader?cacheDirectory']}) 然后在loader中的js候选项中use['happypack/loader?id=babel']

    5. ParallelUglifyPlugin（多进程压缩JS）：

       需要注意的是，项目如果比较小，就没有必要开启多进程进行优化，因为进程需要创建和销毁，这也需要时间

    6. 自动刷新或热更新

    7. DllPlugin：加载完react或者vue的框架之后，版本就不会变化了，这些框架比较大，同一个版本只需要构建一次即可，不需要每次都重新构建。webpack内置了这个插件，首先新建一个webpack.dll.js文件，从`webpack/lib/DllPlugin`中引入这个插件，

  + 优化产出代码：

    1. 小图片base64编码
    2. 打包出来的文件是带hash值的
    3. 懒加载
    4. 提取公用代码
    5. 使用CDN加速
    6. 使用mode:production，会自动压缩代码，自动删掉调试代码，自动tree-shaking
    7. 



## document.ready与 window.onload

+ ready事件说的是在DOM树加载完成之后就会执行
+ onload事件说的是当页面上的包括图片，音视频等资源加载完成之后才执行





## 大文件上传

第一种方案：采用formData的格式通过ajax请求传递，然后服务器端创建文件，把服务器存储的文件地址返回给客户端

```javascript
// 限制文件类型 可以在标签中添加 accept="images/*"
// 通过md5 转化成数字和字符 可以再加一个时间戳，防止服务器端命名冲突
fileInp.onchange = function() {
  // files 包括上传的图片
  let file = fileInp.files[0]
  if(!file) return
  let formData = new formData()
  // 默认有Content-Type: mutil/form-data
  formData.append('chunk', file)
}

```



第二种方案：采用数据流，将文件当前的base64编码传过去，将base64转化成具体的图片存储，返回文件存储的地址





大文件上传，客户端会把大文件切片化，利用http并发传递，利用Blob类，我们在input标签里面上传的file其实是Blob的一个实例，通过Blob原型的slice方法就可以把文件切片处理。

切片之后，同时并发，等上传完事后，再向服务器发送一个合并的请求，服务器会先创建一个临时的目录，收到合并请求之后，会把切片的信息合并到最后一个图片中，然后删除临时的目录。



前端这边需要固定切片大小或者是切片的数量。

```javascript
let partSize
```



这两个方案都是可以的，而且用的都很多，都需要进行分流处理



## 类数组

类数组是一个对象，键是从0开始，有两个比较重要的属性，一个是length，一个是Symbol(Symbol.iterator)

转换成数组的方法有Array.from   [].slice.call()   [...arguments]





## LeetCode

+ 位运算

  + 0^N = N N^N = 0 （返回只出现一次的数）

  + 10 100 1000 10000  n&(n-1) 的值判断2的幂

  + `n & (n - 1)` 可以`消除` n 最后的一个1

  + 换底公式 用于

  + ```javascript
    // 换底公式
    var isPowerOfThree = function(n) {
        const power = Math.log10(n)/Math.log10(3)
        return Number.isInteger(power)
    };
    ```




+ KMP

  

## 项目

1. 需求分析

   ```javascript
   // 1. 了解需求背景
   // 2. 质疑需求是否合理
   // 3. 需求是否闭环
   // 4. 开发难度如何
   // 5. 是否需要其他支持
   // 6. 不要急于给排期
   ```

2. 技术方案设计

   ```javascript
   // 1. 求简 不要过度设计，用到的一切技术都要考虑实现的成本，在实现相同的效果前提下，怎么简单怎么来，不要为了应用某个技术而去在项目中使用某个技术
   // 2. 产出文档  有文字描述，代码描述，画图，切勿眼高手低，不要带着没有搞明白的问题就去写代码
   // 3. 找准设计重点  
   // 4. 组内评审
   // 5. 与后端定字段和接口
   ```

3. 如何保证代码质量

   ```javascript
   // 1. 综合考虑排期，首先要考虑
   // 2. 保持git 注释  模块 等规范  配套一定的开发文档
   // 3. 及时单元测试
   // 4. MockApi
   // 5. Code Review 
   // 6. 让UE和PM尽早介入，不要等到项目上线了之后，才发现
   ```

4. PM加需求怎么办

   这个不能拒绝，如果公司里面有需求变更的流程规定，还是按照规定走，如果没有的话，要发起一次评审，重新排期。

5. 测试问题要详细记录





## 经历

1. 案情分析平台

   ```javascript
   // 这个项目主要功能是根据警员录入的文本，使用模型进行解析，将文本中重要的数据字段进行提炼，解析成理想的格式，前端这一块主要是三个部分的，一个是案情图谱，也就是将数据块化，通过连线将数据块之间连接，将一个普通的案情的文本转换成一个信息明确，关系明确的图谱，警员在看到这个图谱之后能够更加直观地了解这个案情的描述，而不是人为地去阅读文本自己去构建这样的关系图；第二块是地图的业务，这个比较棘手，由于那个时候驻场的地区是在上海，那边硬性要求支持ie10，所以当时换了许多地图服务，很多地图仿佛是放弃了支持ie一样，简单地操作地图一分多钟，就会爆栈，所以最后换用了这个国外开源的一个地图，acgis，
   ```

2. 消息检索系统

   ```javascript
   // 这个项目的主题思路也是依据模型解析文本，这里的文本也是要通过模型过滤的，根据文本的内容，模型可以迅速判断出，这段内容涉及的类型以及关键词
   ```

   

