# 算法(JavaScript)

常数时间操作：一个操作如果和样本的数据量没有关系，每次都是固定时间完成

判断复杂度的时候要保留高阶项，去掉低阶项

## 排序

1. 冒泡排序
2. 选择排序
3. 插入排序

## 位运算

能够使用位运算就使用位运算。

## 栈

只能在一端添加和删除，也就是入栈和出栈操作，后进先出。

```javascript
function Stack () {}
```

## 集合

```javascript
function Set() {
  this.items = {
    
  }
  Set.prototype.has = function (value) {
    return this.items.hasOwnProperty(value)
  }
  Set.prototype.add = function (value) {
    if (this.has(value)) {
      return false
    }
    this.items[value] = value
  }
  Set.prototype.remove = function (value) {
    if (!this.has(value)) {
      return false
    }
    delete this.items[value]
    return true
  }
}
```

## 树

+ 二叉搜索树

  1. 非空左子树的所有键值小于其根节点的键值
  2. 非空右子树的所有键值大于其根节点的键值
  3. 左，右子树本身也都是二叉搜索树
  4. 由于查找和删除操作的效率与树的深度有关系，所以如果一个二叉搜索树不平衡，那么效率将非常低，在非常极端的情况下，最终可能会形成链表，这个时候我们会使用平衡二叉树

+ 平衡二叉树

  1. 每个节点左边的子孙节点的个数应该竟可能等于右边的子孙节点个数
  2. AVL树

  ​

  1. 红黑树（效率比AVl树高）

  + 红黑树是红色或者黑色

  + 根节点是黑色

  + 任何包含数据的节点都不能作为叶子节点，也就是说每个叶子节点都是黑色的空节点

  + 每个红色节点的两个子节点都是黑色的，每个叶子节点到根的所有路径上不能有两个连续的红色节点

  + 从任意一个节点到其每个叶子的所有路径都包含相同数目的黑色节点

    插入操作：

    1. 换色->左旋转->右旋转（插入的新节点默认是红色的）
    2. ​

    ​