# 前端笔记

## 浏览器

浏览器功能:呈现web资源.

工作机制:

1. 输入网址 
2. 浏览器查找域名的`IP`地址。 
3. 浏览器给web服务器发送一个`HTTP`请求 
4. 网站服务的永久重定向响应 
5. 浏览器跟踪重定向地址 现在，浏览器知道了要访问的正确地址，所以它会发送另一个获取请求。 
6. 服务器“处理”请求，服务器接收到获取请求，然后处理并返回一个响应。 
7. 服务器发回一个`HTML`响应 
8. 浏览器开始显示`HTML` 
9. 浏览器发送请求，以获取嵌入在`HTML`中的对象

我们先来了解一下一个`html`页面怎么被渲染最后呈现到浏览器用户眼前的.

### 渲染

由渲染引擎执行,会解析三种文件,`HTML`,`CSS`与`JS`,主要会经历这几个步骤

1. 解析`html`以构建`dom`树 -> 2. 构建`render`树 -> 3.布局`render`树 ->4. 绘制`render`树

渲染引擎会首先渲染解析`HTML`文件,第一步将每个`html`元素转换成一个`DOM`节点构建一棵`DOM`树,样式信息与HTML中的可视化指令一起用于创建渲染树,在构建渲染树后,根据`CSS`中的位置属性参与布局过程,每个`DOM`节点有自己的确切的坐标,最后是绘制阶段,渲染引擎将遍历整个渲染树,并使用UI后端层绘制每个节点.

输出树 - 解析树是DOM元素和属性节点的树。它是HTML文档的对象呈现和HTML元素与外部世界的接口.HTML5规范描述了解析算法,该算法包括两个阶段 - 标记化和树形结构。标记化是词法分析，将输入解析为标记。HTML标记包括开始标记，结束标记，属性名称和属性值。

- 标记化算法

初始状态是“数据状态”。遇到“<”字符时，状态将更改为**“标记打开状态”**。使用“az”字符会导致创建“开始标记令牌”，状态将更改为**“标记名称状态”**。我们保持这种状态直到消耗“>”字符。每个字符都附加到新令牌名称。到达“>”标记时，将发出当前标记，并且状态将更改回**“数据状态”**。

- 树构造算法

创建解析器时，将创建Document对象。在树构建阶段，将修改其根目录中包含Document的DOM树，并将元素添加到其中。标记生成器发出的每个节点都将由树构造函数处理。对于每个标记，规范定义哪个DOM元素与其相关，并将为此标记创建。除了将元素添加到DOM树之外，它还被添加到一堆开放元素中。

- 渲染树

在构建DOM树时，浏览器构造另一个树，即渲染树。该树具有视觉元素，按其显示顺序排列。它是文档的直观表示。此树的目的是以正确的顺序绘制内容。构建渲染树需要计算每个渲染对象的可视属性。渲染器对应于DOM元素，但关系不是一对一的。非可视DOM元素不会插入渲染树中。此外，显示属性分配为“无”的元素也不会出现在树中（具有“隐藏”可见性属性的元素将显示在树中）。

- 布局

创建渲染器并将其添加到树中时，它没有位置和大小。计算这些值称为布局或重排。布局是一个递归过程。它从根渲染器开始，它对应于HTML文档的元素。布局以递归方式继续通过部分或全部帧层次结构，计算需要它的每个渲染器的几何信息。

- 绘制

在绘制阶段，遍历渲染树并调用渲染器“绘制”方法以在屏幕上显示其内容。

### 脚本

网络模型是同步的。解析文档会暂停，直到执行脚本为止。如果脚本是外部的，则必须首先从网络中获取资源 - 这也是同步完成的，解析将暂停，直到获取资源。Webkit和Firefox都进行了这种优化。在执行脚本时，另一个线程会解析文档的其余部分，并找出需要从网络加载的其他资源并加载它们。这些方式可以在并行连接上加载资源，整体速度更好。注意 - 推测解析器不会修改DOM树并将其留给主解析器，它只解析对外部脚本，样式表和图像等外部资源的引用。

## HTTP协议

1. http:超文本传输协议
2. https:安全的超文本传输协议,不容易被攻击

### 版本

http:一次性链接;http1.1:保持链接;http2.0:强制https,自带双向通信.

###数据交互

1. 表单 action:提交地址,method: 方式
2. ajax(接收的时候,先接收头,再接收体)
3. jsonp
4. websocket(双向通信默认可以跨域)

## Angular



## React

### 虚拟dom

需要先解释DOM：DOM是使用JavaScript对象来表示页面中的元素

而虚拟dom是框架中的概念，是我们程序员用js对象来模拟页面上的DOM和嵌套DOM。

真正的 DOM 元素非常庞大，这是因为标准就是这么设计的。我们平时在使用JavaScript操作DOM时，其实就是对页面进行重排和重绘，其实这是非常消耗性能的，试想，我们在使用ajax发送异步请求后，我们会得到一些数据，我们平时对页面的操作，其实是对数据的操作，就像一个数组，如果它的长度很长，那么我们大可不必要关心那些没有变化的数据，换句话说，数组中的某项或者多项，在数组中如果没有数值以及位置上的变化，我们是没有必要对这些项进行重排或者重绘的，顺着这个想法，我们只需要处理那些变动的东西，一样可以使页面得到相应的更新，与此同时，还可以大幅度地提高性能。

相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。那么问题来了，我们在操作DOM时，实际上是通过浏览器提供的各种API，获得页面中的各个元素，使得我们可以修改每个元素的属性与样式，以此间接地修改DOM树，而DOM树本身并没有提供接口让我们直接可以操作我们熟悉而又陌生的DOM树，因为我们无法获取浏览器内存中的整个DOM树。为了解决这个问题，框架就诞生了，我们致力于构造两个DOM树，用后生成的DOM与之前生成的DOM树进行对比，只需要更新不同的地方即可，而创造这两个DOM树的方法，还是使用我们熟知的`JavaScript`。试想下面的Html：

```html
<div id="myDiv" title="说实话">我挺帅的
    <p>哈哈哈</p>
</div>
```

这个代码没有什么难度，但是我们可以通过`JavaScript`模拟构造这么一个html的元素：

```javascript
var div = {
    tagName: 'div',
    attrs: {
        id: 'myDiv',
        title: '说实话'
    },
    childrens: [
        '我挺帅的',
        {
         	tagName: 'p',
            attrs: {},
            childrens: [
                '哈哈哈'
            ]
        }
    ]
}
```

DOM的嵌套我们可以通过`childrens`属性来嵌套.用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作,但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的DOM操作，然后把它们应用在真正的 DOM 树上，页面就变更了。

所谓的虚拟DOM，其实就是使用JavaScript的形式，来模拟页面DOM之间的嵌套关系，即，虚拟DOM是以JS对象的形式存在的，其本质是为了实现页面元素高效的按需更新。Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。

### Diff算法（差异查询算法）

- `tree diff`

  新旧两颗DOM树，逐层对比的过程，当该过程的完成，就能够找到需要更新的元素。

- `component diff`

  在进行tree diff的过程中，组件之间的对比。如果对比前后，组件的类型相同，如果类型相同，则暂时认为这个组件不需要被更新。如果组件类型不同，则需要移除旧组件，创建新的组件，并追加到页面上

- `element diff`

  在进行component diff的过程中，如果两个组件相同，则需要进行元素级别的对比。

三个diff算法逐层递进，使得整两个DOM树的对比没有遗漏。



### 安装

运行`npm i react react-dom -S`安装包

- react:  专门用于创建组件和虚拟DOM的，同时组件的声明周期都在这个包中
- react-dom: 专门进行dom操作，主要用于`ReactDOM.render()`，将我们生成好的虚拟DOM渲染到页面上（因为我们生成的虚拟DOM在浏览器的内存中）

### 语法

```javascript
function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}
// 定义变量
const user = {
  firstName: 'Harper',
  lastName: 'Perez'
};
// 声明一个React元素
const element = (
  <h1 tabIndex="0" title={user.avatarUrl}>
    Hello, {formatName(user)}!
  </h1>
);
// 上述的声明等价于
// const element = {
//   type: 'h1',
//   props: {
//     className: 'greeting',
//     children: 'Hello, world'
//   }
// };

// 使用render函数将上述标签挂载到id为root的DOM元素中
ReactDOM.render(
  element,
  document.getElementById('root')
);
```

在React元素中，使用JavaScript表达式需要使用`{}`进行包裹，不论是标签上的属性还是标签内部需要渲染的数据。React 元素都是不可变的。当元素被创建之后，你是无法改变其内容或属性的。一个元素就好像是动画里的一帧，它代表应用界面在某一时间点的样子。

```javascript
// Fragment由React16版本提供,本身是一个占位符,不会渲染到页面上,因此不会影响组件的CSS样式或者布局
import React, { Component, Fragment } from 'react';

class TodoList extends Component{
    render() {
        return (
            // <Fragment> 标签进行占位
            <Fragment>
                <div><input type="text"/><button>提交</button></div>
                <ul>
                    <li>学英语</li>
                    <li>learning React</li>
                </ul>
            </Fragment>
        )
    }
}

export default TodoList;
```

### 组件

使用脚手架工具的时候,`index.js`文件是整个项目的入口文件

```react
import React from 'react';
import ReactDOM from 'react-dom';

// 加载一个App组件
import App from './App';

// 这个函数将App组件挂载到id是root的节点上
ReactDOM.render(<App />, document.getElementById('root'));
```

组件定义的语法:

```react
import React, { Component } from 'react';
// 通过类的继承,定义一个App类来继承React下的Component类，组件名的作为标签使用时,必须使用大写,`jsx`中的html代码必须有元素包裹,否则报错
class App extends Component {
  // render函数是Component类的内置函数,render函数返回什么,页面之中就显示什么
  render() {
    return (
      <div>
        hello world
      </div>
    );
  }
}
// 将组件暴露出去,以便其他文件import
export default App;

```

可以把组件理解成一个函数，他可以接收任意的输入值（props），并返回一个需要在页面上展示的React元素。当React遇到的元素是用户自定义的组件，它会将JSX属性作为一个单个对象（props）传递给该组件。注意，组件本身不能修改自己的props，即必须像纯函数那样使用props。

### 响应式设计思想与事件绑定

不要操作`dom`,React永远操作的都是数据.数据定义语法:

```react
class TodoList extends Component{
    // 因为TodoList是一个类,那么它一定有constructor这个构造函数,我们在使用TodoList的时候,这个函数会被最先执行
    constructor(props) {
        super(props);
        // state用来存储数据
        this.state = {
            inputValue: '',
            list: []
        }
    }
    render() {

        return (
            <Fragment>
                <div>
                    <input
                        {/*数据绑定 注意{}来包裹React表达式*/}
                        value={this.state.inputValue}
                        {/*在绑定事件时一定要通过bind函数来修改this指向*/}
                        onChange={this.handleInputChange.bind(this)}
                    />
                    <button>提交</button>
                </div>
                <ul>
                    <li>学英语</li>
                    <li>learning React</li>
                </ul>
            </Fragment>
        )
    }
	// 注意: react中不允许直接改变state中的数据,必须通过setState函数对其进行重新赋值
    handleInputChange(e) {
        this.setState({
            inputValue: e.target.value
        })
    }
}

export default TodoList;
```

### 组件之间传值

React中组件之间的传值是单项的,父组件向子组件传值通过属性传值,而子组件向父组件传值通过触发函数来传值:

```react
// 父组件
class TodoList extends Component{
    constructor(props) {
        super(props);
        this.state = {
            inputValue: '',
            list: []
        }
        this.handleInputChange = this.handleInputChange.bind(this);
        this.handleBtnClick = this.handleBtnClick.bind(this);
        this.handleItemDelete = this.handleItemDelete.bind(this);
    }
    render() {

        return (
            <Fragment>
                {/*我是一个注释*/}
                <div>
                    <input
                        className='input'
                        value={this.state.inputValue}
                        onChange={this.handleInputChange}
                    />
                    <button
                        onClick={this.handleBtnClick}
                    >提交</button>
                </div>
                <ul>{ this.getTodoItem() }</ul>
            </Fragment>
        )
    }

    getTodoItem() {
        return this.state.list.map((item, index) => {
            // 子组件调用
            return <TodoItem
                key={index}
                deleteItem={this.handleItemDelete}
                content={item}
                index={index}
            />
        })
    }

    handleInputChange(e) {
        const value = e.target.value;
        this.setState(() => ({
            inputValue: value
        }))
    }

    handleBtnClick() {
        this.setState((prevState) => ({
            list: [...prevState.list, prevState.inputValue],
            inputValue: ''
        }))
    }
    handleItemDelete(index) {
        this.setState((prevState) => {
            const list = [...prevState.list];
            list.splice(index, 1);
            return { list }
        })
    }
}

// 子组件
class TodoItem extends Component {
    constructor(props) {
        super(props);
        this.handleClick = this.handleClick.bind(this);
    }
    render() {
        const { content } = this.props;
        return <div onClick={this.handleClick}>{ content }</div>
    }

    handleClick() {
        const { deleteItem, index} = this.props;
        deleteItem(index)
    }
}
```

我们可以观察到子组件在接受父组件的数据或者函数的时候，都是通过`this.props`来接收。

注意写法：

1. 在组件中实现函数绑定的时候最好在`constructor()`中完成，否则影响性能
2. 竟可能将比较长的jsx代码封装到函数中然后返回，在render函数中直接调用这个函数即可
3. 竟可能使用解构赋值来解构`this.props`

- 属性校验

  1. `import PropTypes from 'prop-types'`引入属性校验的包,脚手架自带

  2. `propTypes`指定每个从父组件获得的属性或者函数的类型

     ```react
     TodoItem.propTypes = {
         // isRequired表示该属性或者方法必须传入
         test: PropTypes.string.isRequired,
         content: PropTypes.string.isRequired,
         deleteItem: PropTypes.func,
         index: PropTypes.number
     }
     ```

  3. `defaultProps`指定每个属性或者方法的默认值,如果父组件没有传入,则使用默认值代替:

     ```react
     TodoItem.defaultProps = {
         test: 'hello world'
     }
     ```

- `props,state与render()`的关系:当组件的`state`或者`props`发生改变的时候,`render()`就回重新执行

### 生命周期函数

在某一个时刻,组件会自动调用的函数.

React组件在创建的时候会经历4个过程:

- Initialization(初始化数据)

  `constructor()`负责对`state`与`props`进行初始化

- Mounting(渲染并挂载),挂载的意思就是组件第一次出现在页面中的时候

  `componentWillMount()`在组件即将被挂载到页面的时刻自动调用

  `render()`挂载组件

  `componentDidMount()`组件被挂载到页面之后自动调用,这里常常写一些ajax请求

  ```react
  // 引入axios插件来发送ajax
  import axios from 'axios'
  
  // 在生命周期函数之中这么写
  componentDidMount() {
          axios.get('/api/todolist').then(() => {
              console.log('success');
          }).catch(err => {
              console.log(err);
          })
      }
  ```

- Updation(组件更新的过程),即数据(props或者state)发生变化

  `shouldComponentUpdate()`组件数据更新之前自动调用,注意这个函数必须返回一个布尔类型的结果,类似于询问->需要更改组件嘛?所以如果返回true,意思就是,需要更新,就回继续执行下面的生命周期函数.

  `componentWillUpdate()`在`shouldComponentUpdate()`返回true后执行,表示组件的数据即将被更新.

  `render()`再次被调用

  `componentDidUpdate()`在组件的数据完成更新后自动调用

  > 注意,上述的数据生命周期函数只针对state中的数据,在props中`componentWillReceiveProps()`当一个组件从父组件接收参数时,当父组件的render函数被执行的时候,这个生命周期函数会被执行.

- Unmounting

  `componentWillUnmount()`当组件即将在页面中被剔除的时候自动调用

### CSS过渡动画

```react	
class App extends Component {
    constructor(props) {
        super(props);
        this.state = {
            show: true
        }
        this.handleToggle = this.handleToggle.bind(this);
    }
    
    render() {
        return (
        	<Fragment>
                <div className={this.state.show ? 'show' : 'hide'}>hello</div>
                <button onClick={this.handleToggle}>toggle</button>
            </Fragment>
        
        )
    }
    handleToggle() {
        this.setState({
            show: this.state.show ? false : true
        })
    }
}
```

```css
.show {
    animation: show-item 2s ease-in forwards;
}

.hide {
    animation: hide-item 2s ease-in forwards;
}

@keyframes show-item {
    0% {
        opacity: 0;
        color: red;
    }
    50% {
        opacity: 0.5;
        color: green;
    }
    100% {
        opacity: 1;
        color: blue;
    }
}

@keyframes hide-item {
    0% {
        opacity: 1;
        color: red;
    }
    50% {
        opacity: 0.5;
        color: green;
    }
    100% {
        opacity: 0;
        color: blue;
    }
}

```

`react-transition-group`的使用:

1. 

### Redux

`React`只是一个轻量级的视图层框架,在项目中无法解决组件之间复杂的数据传递问题:比如组件越级获取数据,越级触发父组件,所以在开发项目的过程中,我们需要搭配数据层的框架来实现业务功能.`Redux`就是非常优秀的数据层框架.

`Redux = Reducer + Flux`

模拟借书流程:

- 组件(`Component`):借书的人
- `Action Creators`:借书人的需求(即:需要借什么样的书)
- `Store`:图书管的管理员(负责管理各种书籍)
- `Reducers`:管理员手上的书籍记录

所以,Redux的工作流程就可以是这样,借书的人想要借书,所以他需要找到图书管理员,告诉他我需要什么样的书籍,图书管理员没有办法记住所有的书本信息,所以掏出了小本本找到借书人想要借的书,然后将这本书借给借书人.

```react
// 新建store仓库
```

其中:`store`是唯一的,在`/store`文件下的`index.js`文件中,`reducer`拿到`store`中的数据进行深拷贝,对深拷贝后的数据进行处理,并返回,`store`拿到新的数据对自己本身存储的数据进行更新.

> 注意:`reducer`必须是一个纯函数,即给定输入一定会有输出,而且这个输出是固定的,而且这个函数不能有任何的副作用.

### Redux-thunk



## Vue

### 基本语法

```vue
<div id="app">
    {{ content }}
</div>
<script>
    var app = new Vue({
        el: '#app',
        data: {
            content: 'hello world1'
        }
    })
    setTimepit(() => {
        app.$data.content = 'bye world'
    })
</script>
```

通过`new`操作符实例化一个Vue对象,该对象的`el`属性表示这个Vue对象挂载的目标,这个案例中是`id`值为app的DOM元素.而data属性是这个Vue对象的数据,里面可以定义任意多的数据,这样Vue对象可以将数据的值渲染到已经挂载的目标对象.可以通过`app.$data.content`来获取Vue对象中数据名为`content`的数据值.

### 指令

```vue
<div id="app">
    <input type="text" v-model="inputValue">
    <button @click="handleBtnClick">提交</button>
    <ul>
        <li v-for="item in list">{{item}}</li>
    </ul>
</div>
<script>
    var app = new Vue({
        el: '#app',
        data: {
            list: ['123', '456', '789'],
            inputValue: ''
        },
        methods: {
            handleBtnClick() {
                this.list.push(this.inputValue);
                this.inputValue = '';
            }
        }
    })
</script>
```

`v-model`指令:可以对Vue对象的数据进行双向绑定,所谓双向绑定,当修改input框中的value时,被v-model绑定的data数据就回修改,我们在修改被绑定的data数据的时候,input框中的value也会改变

`v-on`指令:将方法绑定给一个标签,方法有不同的触发方法,这里是我们比较常见的点击事件,这里绑定的语法可以用`@`代替,当被`v-on`绑定的方法被触发的时候,Vue会自动到对象app中去寻找这个方法,然后调用.

`v-for`指令:循环遍历app对象中data的一个列表数据.

`v-if`指令:条件渲染,在DOM中直接插入或者删除元素

`v-show`指令:也是条件渲染,不过是将元素的样式`display`的值设置为`none`,如果元素要在页面之中频繁切换,应该使用这个指令来提高性能,毕竟DOM的删除和插入是直接操作DOM

### MVVM模式

`mvvm`模式(model-view-modelView):通过modelView作为中间层（即vm的实例），即模型-视图-视图模型。【模型】指的是后端传递的数据。【视图】指的是所看到的页面。【视图模型】mvvm模式的核心，它是连接view和model的桥梁。它有两个方向：一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。总结：在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。

渲染原理:

1. 通过建立虚拟dom树`document.createDocumentFragment()`,方法创建虚拟dom树。
2. 一旦被监测的数据改变，会通过`Object.defineProperty`定义的数据拦截，截取到数据的变化。
3. 截取到的数据变化，从而通过订阅——发布者模式，触发Watcher（观察者）,从而改变虚拟dom的中的具体数据。
4. 最后，通过更新虚拟dom的元素值，从而改变最后渲染dom树的值，完成双向绑定

`Object.defineProperty()`会在一个对象上定义一个新属性,或者修改一个对象的现有属性,并返回一个对象.上代码:

```javascript
var obj = {};
Object.defineProperty(obj,'hello',{
  get:function(){
    // 我们在这里拦截到了数据
    console.log("get方法被调用");
  },
  set:function(newValue){
    // 改变数据的值，拦截下来
    console.log("set方法被调用");
  }
});
obj.hello//输出为“get方法被调用”，输出了值。
obj.hello = 'new Hello';//输出为set方法被调用，修改了新值
```

在此基础上,我们可以做到简单的双向绑定:

```javascript
var obj = {};
Object.defineProperty(obj,'hello',{
  get:function(){
    //我们在这里拦截到了数据
    console.log("get方法被调用");
  },
  set:function(newValue){
    //改变数据的值，拦截下来额
    console.log("set方法被调用");
    document.getElementById('test').value = newValue;
    document.getElementById('test1').innerHTML = newValue;
  }
});
document.getElementById('test').addEventListener('input',function(e){
  // 修改obj.hello的值,触发该属性的set方法
  obj.hello = e.target.value;
})
```

html:

```html
<div id="mvvm">
    <input v-model="text" id="test"></input>
	<div id="test1"></div>
</div>
```

实现Vue:

```javascript
function nodeContainer(node, vm, flag){
  var flag = flag || document.createDocumentFragment();
  var child;
  while(child = node.firstChild){
    compile(child, vm);
    flag.appendChild(child);
    if(child.firstChild){
      // flag.appendChild(nodeContainer(child,vm));
      nodeContainer(child, vm, flag);
    }
  }
  return flag;
}

function compile(node, vm){
  var reg = /\{\{(.*)\}\}/g;// 匹配双绑的双大括号
  if(node.nodeType === 1){
    var attr = node.attributes;
    // 解析节点的属性
    for(var i = 0;i < attr.length; i++){
      if(attr[i].nodeName == 'v-model'){
        var name = attr[i].nodeValue;
        node.addEventListener('input',function(e){
          console.log(vm[name]);
          vm[name] = e.target.value;//改变实例里面的值
        });
        node.value = vm.data[name];// 讲实例中的data数据赋值给节点
        // node.removeAttribute('v-model');
      }
    }
  }
  // 如果节点类型为text
  if(node.nodeType === 3){  
    if(reg.test(node.nodeValue)){
      var name = RegExp.$1; // 获取匹配到的字符串
      name = name.trim();
      node.nodeValue = vm.data[name];
    }
  }
}

function Vue(options){
  this.data = options.data;
  
  var id = options.el;
  observe(data,this);
  var dom = nodeContainer(document.getElementById(id),this);
  document.getElementById(id).appendChild(dom);  
}

var Demo = new Vue({
  el:'mvvm',
  data:{
    text:'HelloWorld',
    d:'123'
  }
})
```

data属性的响应式:

```javascript
function defineReactive (obj, key, value){
  Object.defineProperty(obj,key,{
    get:function(){
      console.log("get了值"+value);
      return value;//获取到了值
    },
    set:function(newValue){
      if(newValue === value){
        return; // 如果值没变化，不用触发新值改变
      }
      value = newValue;// 改变了值
      console.log("set了最新值"+value);
    }
  })
}

// 循环调用
function observe (obj,vm){
  Object.keys(obj).forEach(function(key){
    defineReactive(vm,key,obj[key]);
  })
}
```

我们在导入包之后，在浏览器的内存中就多了一个Vue构造函数。

### 组件化

我们可以将页面分离成一个一个小的组件,那么一个大型页面组成就是各种小组件的拼装.

- 全局组件

  ```vue
  <div id="app">
      <input type="text" v-model="inputValue">
      <button @click="handleBtnClick">提交</button>
      <ul>
          <todo-item v-for="item in list" v-bind:content="item">	</todo-item>
      </ul>
  </div>
  <script>
      Vue.component('TodoItem', {
          props: ['content'],
          template: '<li>{{content}}</li>'
      });
      var app = new Vue({
          el: '#app',
          data: {
              list: [],
              inputValue: ''
          },
          methods: {
              handleBtnClick() {
                  this.list.push(this.inputValue);
                  this.inputValue = '';
              }
          }
      })
  </script>
  ```

  我们可以通过Vue自带的`component()`来创建一个全局组件,`template`属性指的是这个组件的标签,`props`属性用来接收父组件传递过来的数据.

- 局部组件

  ```vue
  var TodoItem = {
              props: ['content'],
              template: '<li>{{content}}</li>'
          }
  var app = new Vue({
  	el: '#app',
  	component: {
  		TodoItem: TodoItem
  	},
  	data: {
  		list: [],
  		inputValue: ''
  	},
  	methods: {
  		handleBtnClick() {
  			this.list.push(this.inputValue);
  			this.inputValue = '';
  		}
  	}
  })
  ```

  我们直接定义一个拥有Vue对象的各种属性的JS对象,然后在父组件中通过`component`属性引入这个对象,那么这个父组件中就可以使用这个JS对象,也就是我们所说的子组件.	

- 组件之间的传值(单向数据流)

  父组件通过`v-bind`向子组件传值

  子组件通过`this.$emit()`触发函数来向父组件传值

  > 注意在子组件中,`data`属性必须是一个函数,该组件中所有的数据通过`data`函数return出去,因为组件会被复用,否则会出现组件之间数据共享,相同的子组件,有一个数据改变了,其他的子组件也会跟着改变

  组件参数校验:

  ```javascript
  Vue.component('child', {
        template: '<div>{{content}}</div>',
        props: {
          content: {
            type: String,
            required: false,
            default: 'default value',
            validate(value) {
              return value.length > 5
            }
          }
        }
      });
  ```

  非父子组件传值:发布订阅模式

- `ref`属性,父组件可以通过`refs`的属性获取被`ref`属性标记的DOM元素

  ```vue
    <div id="root">
      <div
        @click="handleDivClick"
        :class="{activated: isTrue}">hello
        <p ref="div1">world</p>
      </div>
    </div>
    <script>
      var app = new Vue({
        el: '#root',
        data: {
          isTrue: false
        },
        methods: {
          handleDivClick() {
            console.log(this.$ref.div1);
            this.isTrue = !this.isTrue;
          }
        }
      });
    </script>
  ```

- 插槽:子组件有一部分内容是根据父组件传递的DOM来进行渲染,这个时候就需要用到插槽

  因为子组件标签的内部是不允许直接插入别的标签的,所以如果我们想要在子组件中放入一些别的东西,我们可以在子组件定义的时候加入`<slot>默认内容</slot>`,这个位置可以理解成一个预留的位置,子组件给父组件暴露了一个标签的位置,父组件可以在调用子组件的时候向子组件里面插入一个标签,如果父组件没有插入任何标签,则会显示插槽中的默认内容.

  **具名插槽**:父组件在往子组件插入标签的时候,可以给插入的标签一个`slot`属性,比如

  ```html
  <child>
      <div slot="header">头部信息</div>
      <div slot="footer">底部信息</div>
  </child>
  ```

  然后,在子组件的模板中对这两个标签(`div`)设置具名插槽来显示他们:

  ```html
  <div>
      <slot name="header"></slot>
      <div>体部信息</div>
      <slot name="footer"></slot>
  </div>
  ```

  **作用域插槽**：当父组件向子组件传递数据是一个列表，子组件需要根据父组件传递的数据循环渲染子组件时，需要用到匿名插槽：

  ```html
  <child>
      作用域插槽必须用template标签包裹
      <template slot-scope="props">
          <h1>{{props.item}}</h1>
      </template>
  </child>
  
  
  <--！子组件中 -->
  <div>
      <ul>
          <slot v-for="item of list" :item=item></slot>
      </ul>    
  </div>
  ```

### 动画

需要添加动画的标签必须被<transition></transition>标签包裹

```html
<transition name="fade">
  <div v-if="show">
    hello
  </div>
</transition>
```

Vue在遇到`tansition`标签的时候会创建一个动画流程（显示与隐藏）：

1. 在动画即将执行的一瞬间，会向内部的标签增加两个样式类：`fade-enter`&`fade-enter-active`
2. 开始执行：也就是动画执行的第二针的时候，会去掉第一步的：`fade-enter`样式类，并且加入`fade-enter-to`这个样式类
3. 动画即将结束的时候，会去掉`fade-enter-active`&`fade-enter-to`两个样式类

  隐藏也是一样的：

1. 在动画即将执行的一瞬间，会向内部的标签增加两个样式类：`fade-leave`&`fade-leave-active`
2. 开始执行：也就是动画执行的第二针的时候，会去掉第一步的：`fade-leave`样式类，并且加入`fade-leave-to`这个样式类
3. 动画即将结束的时候，会去掉`fade-leave-active`&`fade-leave-to`两个样式类

`animate.css`库的使用：首先必须导入animate这个库，然后需要定义`enter-active-class`&`leave-active-class`，即入场与出场动画的样式类，样式类需要指定animated，然后后面跟上需要使用的动画效果即可。至于加入的`apper`是为了解决页面刚载入的时候标签没有动画效果的问题。

```html
<transition
    name="fade"
    apper
    apper-active-class="animated swing"
    enter-active-class="animated swing"
    leave-active-class="animated shake"
            
    >
    <div v-if="show">
        hello
    </div>
</transition>

<button @click="handleDivClick">切换</button>
```

过渡效果：

```html

```



### 生命周期钩子

Vue实例在某个时间点会自动调用的方法.所有的生命周期钩子自动绑定 `this` 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。

> 注意:不能使用箭头函数来定义一个生命周期方法。

`beforeCreate()`:实例基础初始化之后,此时还不能数据观测.

`created()`:实例创建完成(初始化完毕)之后立即调用,完成数据观测,属性和方法的运算,但未挂载,所以实例中的`$el`属性是不可见的.

之后,Vue实例会自我判断,是否有`el`属性与`template`属性,即询问是否有挂载点和自身的标签模板,当没有自身模板,它会将挂载点的元素当作自己的自身模板.

`beforeMount`:在实例挂载之前被调用,这个时候数据还没有被渲染到页面上,该钩子函数子在服务器端渲染不被调用.

`mounted`:实例被挂载之后,自动执行,

`beforeUpdate`:数据发生改变,但是还没有被渲染到页面的时候被自动调用

`updated`:数据改变页面重新渲染之后自动调用

`beforeDestroy`:在实例即将被销毁之前调用.

`destroyed`:在实例被销毁之后自动调用.

### 计算属性

我们在书写vue代码的时候尽量不要在模板中加入JavaScript的逻辑表达式,只是进行数据的绑定和数据的渲染,所以如果有需求不得不渲染一些数据直接的逻辑运算的结果,我们可以使用计算属性:

```vue
var app = new Vue({
            el: '#root',
            data: {
                message: 'hello',
                firstName: 'zhang',
                lastName: 'san'
            },
            computed: {
                fullName() {
                    return this.firstName + this.lastName;
                }
				newName: {
                    get() {
						return this.firstName +" "+ this.lastName
                    }
                    set(value) {
						alert(value)
                    }
				}
            }
        });
```

> 计算属性会有缓存,如果它依赖的变量都没有改变,它是不会重新渲染的,其他的变量的改变并不能影响计算属性.

计算属性的`getter`与`setter`:获取计算属性值的时候会调用`getter`函数,设置计算属性值的时候会调用`setter`函数

### 样式绑定

```vue
<style>
    .activated{
        color: red;
    }
</style>
<div id="root">
    <div
         @click="handleDivClick"
         :class="{activated: isTrue}">hello
    </div>
</div>
<script>
    var app = new Vue({
        el: '#root',
        data: {
            isTrue: false
        },
        methods: {
            handleDivClick() {
                this.isTrue = !this.isTrue;
            }
        }
    });
</script>
```

### API

- `Vue.extend()`使用基础 Vue 构造器，创建一个“子类”,参数是一个包含组件选项的对象.

- `Vue.nextTick()`在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

- `Vue.set()`向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新

- `Vue.directive(id,{})`注册或获取全局指令。

- `Vue.component()`注册或获取全局组件。注册还会自动使用给定的`id`设置组件的名称

  ```vue
  // 注册组件，传入一个选项对象 (自动调用 Vue.extend)
  Vue.component('my-component', { /* ... */ })
  
  // 获取注册的组件 (始终返回构造器)
  var MyComponent = Vue.component('my-component')
  ```

### 选项

- `data`  Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化,实例创建之后，可以通过 `vm.$data` 访问原始数据对象。

- `props` props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组

- `computed` 计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果某个依赖 (比如非响应式属性) 在该实例范畴之外，则计算属性是**不会**被更新的。

  ```vue
  var vm = new Vue({
    data: { a: 1 },
    computed: {
      // 仅读取
      aDouble: function () {
        return this.a * 2
      },
      // 读取和设置
      aPlus: {
        get: function () {
          return this.a + 1
        },
        set: function (v) {
          this.a = v - 1
        }
      }
    }
  })
  vm.aPlus   // => 2
  vm.aPlus = 3
  vm.a       // => 2
  vm.aDouble // => 4
  ```

- `methods` methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 `this` 自动绑定为 Vue 实例。

  注意：不能使用箭头函数来定义method函数，因为箭头函数绑定了父级作用域的上下文，所以 `this` 将不会按照期望指向 Vue 实例，`this.a` 将是` undefined`。

- `el` 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。

- `template` 一个字符串模板作为 Vue 实例的标识使用。模板将会 **替换** 挂载的元素。

- `render` 函数

  ```vue
  <h1>{{ blogTitle }}</h1>
  // 或者
  render: function (createElement) {
    return createElement('h1', this.blogTitle)
  }
  ```

  - Vue 通过建立一个**虚拟 DOM** 对真实 DOM 发生的变化保持追踪。

    `createElement`：

    ```vue
    createElement(
      // {String | Object | Function}
      // 一个 HTML 标签字符串，组件选项对象，或者
      // 解析上述任何一种的一个 async 异步函数。必需参数。
      'div',
    
      // {Object}
      // 一个包含模板相关属性的数据对象
      // 你可以在 template 中使用这些特性。可选参数。
      {},
    
      // {String | Array}
      // 子虚拟节点 (VNodes)，由 `createElement()` 构建而成，
      // 也可以使用字符串来生成“文本虚拟节点”。可选参数。
      [
        '先写一些文字',
        createElement('h1', '一则头条'),
        createElement(MyComponent, {
          props: {
            someProp: 'foobar'
          }
        })
      ]
    )
    ```

### Vue-Router（路由插件）

路由就是根据网址的不同，返回不同的内容给用户。

具体使用方法：

1. 在src文件下新建router文件，然后新建`index.js`文件。

2. 在index文件中导入这个插件`import Router from 'vue-router'`

3. 在导出路由配置对象之前，必须先使用这个插件对象`Vue.use(Router)`

4. 接着，使用`new`操作符实例化一个Router对象并将其暴露出去

   ```javascript
   import Vue from 'vue'
   import Router from 'vue-router'
   // 在此导入路由配置需要的组件，这里的@符号指的是src目录
   import HelloWorld from '@/components/HelloWorld'
   
   Vue.use(Router)
   
   export default new Router({
     routes: [
       {
         // 当用户访问根路径的时候，展示HelloWorld这个组件
         path: '/',
         name: 'HelloWorld',
         component: HelloWorld
       }
     ]
   })
   
   ```

5. 在src目录下的入口文件，也就是`main.js`中导入被暴露的路由对象，然后使用这个导入的路由对象

`<router-view/>`显示的就是当前路由地址所对应的内容。

通过注入路由器，我们可以访问它`this.$router`以及`this.$route`任何组件内部的当前路由。

+ 动态路由：

  ```javascript
  const router = new VueRouter({
    routes: [
      // 使用：跟上动态参数id
      { path: '/user/:id', component: User }
    ]
  })
  ```

+ 嵌套路由：

  在一个路由选项中配置其`children`属性（数组），在其中按需添加

  ```javascript
  const router = new VueRouter({
    routes: [
      { path: '/user/:id', component: User,
        children: [
          { path: '', component: UserHome },
          { path: 'profile', component: UserProfile },
          { path: 'posts', component: UserPosts }
        ]
      }
    ]
  })
  ```

+ 路由跳转语法：

  ```html
  <router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link>
  ```

  或

  ```javascript
  // 字符串
  router.push('home')
  
  // 对象
  this.$router.push({path: '/login?url=' + this.$route.path});
  
  // 命名的路由
  router.push({ name: 'user', params: { userId: 123 }})
  
  // 带查询参数，变成/backend/order?selected=2
  this.$router.push({path: '/backend/order', query: {selected: "2"}});
  ```

  

### Vuex（单项数据改变流程）

Vue的数据共享框架，解决了非父子组件之间数据共享的问题。将每个组件都有可能用到的数据放在Vuex中，当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。组件通过dispatch来分发actions中的方法，这些方法来提交mutations中定义的方法，在mutations的方法中来修改state。组件想要修改store中的数据，必须通过上面的步骤，不允许直接修改store中的数据。

具体使用：

1. `npm install vuex --save`下载插件

2. 在`src`目录下新建`store/index.js`

   ```javascript
   // index.js文件下
   import Vue from 'vue'
   import Vuex from 'vuex'
   // 使用这个插件
   Vue.use(Vuex)
   // 使用插件中的Store函数实例一个仓库并且暴露出去
   export default new Vuex.Store({
     state,
     mutations
     //...
   })
   ```

3. 在项目入口文件`main.js`中引入，通过在根实例中注册 `store` 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 `this.$store` 访问到。

   ```javascript
   // main.js文件下
   import Vue from 'vue'
   import App from './App'
   import router from './router'
   import store from './store'
   
   new Vue({
     el: '#app',
     router,
     // 注册
     store,
     components: { App },
     template: '<App/>'
   })
   ```

- state：数据存放的区域

  ```javascript
  // mapState函数辅助生成状态属性
  // 在需要使用store中数据的组件中引入
  import { mapState } from 'vuex'
  
  export default {
    // ...
    computed: mapState({
      // 箭头函数可使代码更简练
      count: state => state.count,
      // 传字符串参数 'count' 等同于 `state => state.count`
      countAlias: 'count',
      // 为了能够使用 `this` 获取局部状态，必须使用常规函数
      countPlusLocalState (state) {
        return state.count + this.localCount
      }
    })
  }
  // 或者
  computed: mapState([
    // 映射 this.count 为 store.state.count
    'count'
  ])
  // 使用对象展开运算符
  computed: {
      ...mapState(['city'])
    },
  ```

+ Getter：类似于组件的computed属性，可以对state状态进行再次包装，Getter 会暴露为 `store.getters` 对象。

  ```javascript
  const store = new Vuex.Store({
    state: {
      todos: [
        { id: 1, text: '...', done: true },
        { id: 2, text: '...', done: false }
      ]
    },
    getters: {
      doneTodos: state => {
        return state.todos.filter(todo => todo.done)
      }
    }
  })
  
  // mapGetters辅助函数
  computed: {
    // 使用对象展开运算符将 getter 混入 computed 对象中
      ...mapGetters([
        'doneTodosCount',
        'anotherGetter',
        // ...
      ])
  ```

- mutations：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。每个 mutation 都有一个字符串的事件类型和一个 回调函数 。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数

  ```javascript
  const store = new Vuex.Store({
    state: {
      count: 1
    },
    mutations: {
      increment (state, n) {
        // 变更状态
        state.count + n
      }
    }
  })
  // 在组件中调用
  this.$store.commit('increment', 10)
  
  // mapMutations辅助函数
  import { mapMutations } from 'vuex'
  
  export default {
    // ...
    methods: {
      ...mapMutations([
        'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`
  
        // `mapMutations` 也支持载荷：
        'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`
      ]),
      ...mapMutations({
        add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`
      })
    }
  }
  ```

- actions：组件通过调用这里存放的异步处理或者批量的同步操作，通过这些操作去调用mutations

### NuxtJs（SSR）

SSR：在服务器端将Vue程序渲染成HTML文件返回给浏览器，因为SEO无法抓取到Vue文件，而且是加载速度比纯SPA页面快很多。

Nuxt：基于Vue的应用框架，主要关注应用的UI渲染。

常用配置项修改：

1. 服务器启动路由修改：

   在`package.json`文件中添加配置项：

   ```javascript
   "config": {
     "nuxt": {
       "host": "127.0.0.1",
       "port": "1818"
     }
   }
   ```

2. 配置项目全局属性都是在`nuxt.config.js`中进行配置，比如全局引入CSS样式文件，就可以找到`"css"`属性，这是个数组，可以添加多个CSS全局样式文件。

3. 

### 写法规范

1. 组件名应该始终是多个单词的,避免跟现有的以及未来的 HTML 元素.

   ```vue
   Vue.component('todo-item', {
     // ...
   })
   
   export default {
     name: 'TodoItem',
     // ...
   }
   ```

2. data必须是一个函数,然后值被return出去:因为当data是一个对象时,它会在组件的所有实例中共享,如果该组件被复用,A组件对数据的修改将会影响另一个组件.

   ```Vue
   data: function () {
     return {
       listTitle: '',
       todos: []
     }
   }
   ```

3. Prop属性应该尽量详细,至少要指定类型

   ```vue
   props: {
     status: {
       type: String,
       required: true,
       validator: function (value) {
         return [
           'syncing',
           'synced',
           'version-conflict',
           'error'
         ].indexOf(value) !== -1
       }
     }
   }
   ```

4. 永远不要把 v-if 和 v-for 同时用在同一个元素上。

5. 单文件组件的文件要么始终是单词大写开头,要么始终是横线连接.

6. 在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case。

   ```vue
   props: {
     greetingText: String
   }
   <WelcomeMessage greeting-text="hi"/>
   ```

7. 属性多行书写:

   ```Vue
   <img
     src="https://vuejs.org/images/logo.png"
     alt="Vue Logo"
   >
   <MyComponent
     foo="a"
     bar="b"
     baz="c"
   />
   ```

8. 组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。

## Webpack

 webpack 处理应用程序时，它会递归地构建一个依赖关系图,其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 *bundle*。

### 入口起点

指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。可以通过配置 `entry` 属性，来指定一个入口起点,默认值为 `./src`.

```javascript
module.exports = {
  entry: './path/to/my/entry/file.js'
};
```

### 出口

**output** 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 `./dist`。

```javascript
const path = require('path');

module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'my-first-webpack.bundle.js'
  }
};
```

### loader

处理非 JavaScript 文件（因为webpack 自身只理解 JavaScript）,loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块. 在 webpack 的配置中 **loader** 有两个目标:`test` 属性(用于标识应该被对应的loader进行转换的文件)与`use` 属性(使用什么loader进行转换).

```javascript
const path = require('path');

const config = {
  output: {
    filename: 'my-first-webpack.bundle.js'
  },
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' }
    ]
  }
};

module.exports = config;
```

当txt文件被导入(require或者import)的时候,先使用`raw-loader`转换一下,再打包.

## 前端工程笔记

1. 在样式中引入样式文件的时候一定要在路径前面加`~`

   ```vue
   <style lang="stylus" scoped>
     @import "~style/varibles.styl"
   </style>
   ```

2. 可以通过`webpack.base.config.js`对一些常用路径进行配置，记得修改了之后要重启服务器：

   ```vue
    resolve: {
       extensions: ['.js', '.vue', '.json'],
       alias: {
         'vue$': 'vue/dist/vue.esm.js',
         '@': resolve('src'),
         'style': resolve('src/assets/style')
       }
    },
   ```

3. 对于没有后端支持的前期，如果需要访问接口，可以在`/static`目录下新建`/mock`文件夹，然后在该文件中增加本地数据项，然后在`/config`目录下的`index.js`文件中找到`dev`属性，对其proxyTable属性进行配置，意思就是可以通过这个配置项目，将ajax请求代理到开发者想要代理的位置：

   ```javascript
   proxyTable: {
         '/api': {
           target: 'http://localhost:8080',
           pathRewrite: {
             '^/api': '/static/mock'
           }
         }
       },
   ```

4. 性能优化问题-数据多造成的渲染延时

   可以通过制作表格分页，按需渲染查看数据，这样渲染的数据量比较小，不会存在明显的延时问题。

5. 性能优化问题-函数节流提高用户频繁操作产生的渲染问题

   ```javascript
   if (timer) {
       clearTimeout(timer)
   }
   timer = setTimeout(() => {
       // ...
   }, 16)
   ```


