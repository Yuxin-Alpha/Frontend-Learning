# 源码分析

在解析源码之前，需要先了解几个技术点

1. `[].slice.call(obj)`：将伪数组转化为真数组，所谓伪数组，其实就是一个对象，而这个对象拥有`length`属性，而且我们可以通过下标的方式去找到某个属性。

2. `node.nodeType`：节点类型

3. `Object.defineProperty(obj, propertyName, {})`：给对象添加属性，后面的对象是属性描述符

   属性描述符里面有两个比较重要的函数：

   ```javascript
   {
       // 属性在内存中的值
       value: ''
       // 是否可以重新定义
       configurable: true,
       // 是否可以枚举
       enumerable: true,
       // 是否可以重写属性值
       writable: true,
       // 可以动态某个属性的value
       get: function () {
           // ...
       }
       // 监听某个属性value值的的变化
       set: function () {
           // ...
       }
   }
   ```

4. `Object.keys(obj)`：得到对象自身可枚举属性组成的数组

5. `obj.hasOwnProperty('prop')`：判断prop是否是obj自身上面的属性

6. `DocumentFragment`：减少更新界面的次数，内存中保存n个element的容器对象(不与界面关联)，如果更新fragment，页面只是更新一次。

## 数据代理

通过一个对象代理对另一个对象中属性的读写。

基本流程：

+ 通过`Object.defineProperty()`给实例添加与data对象的属性对应的属性描述符
+ 重写`getter/setter`去操作data中的对应的属性数据

```javascript
// MVVM.js　定义Vue的构造函数
function MVVM(options) {
    // 将配置对象传入实例的$options中
    this.$options = options;
    // 将配置对象中的data属性赋值给实例的_data属性
    var data = this._data = this.$options.data;
    // 存储当前实例
    var me = this;
    // 数据代理
    Object.keys(data).forEach(function(key) {
        me._proxy(key);
    });
    
}

MVVM.prototype = {
    _proxy: function(key) {
        var me = this;
        Object.defineProperty(me, key, {
            // 不能重新定义
            configurable: false,
            // 可以枚举
            enumerable: true,
            // 读取_data的属性值
            get: function proxyGetter() {
                return me._data[key];
            },
            // 修改_data中的属性时，会触发，将newVal赋值给当前属性值
            set: function proxySetter(newVal) {
                return me._data[key] = newVal;
            }
        });
    }
}

```

## 模板解析

基本流程：

+ 

```javascript

```







