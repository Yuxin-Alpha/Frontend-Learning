# 浏览器

## 进程与线程

进程仿佛一个工厂，工厂里面有资源，比如各种各样的原材料，而线程仿佛一个工厂里面的工人，一个工厂里面可以是一个人干活，也有可能是多个人干活，这些人面对工厂内部的资源是平等的，也就是说，每个线程都可以利用进程的资源（cpu,内存）。我们常说，进程是计算机分配资源的最小单位，也就是说，比进程还小的单位，是不会被分配内存的。

浏览器是多进程的，浏览器之所以能够运行，是计算机给浏览器进程分配了资源。每打开一个Tab页，都是新开一个浏览器进程（独立的）。介绍一下浏览器的进程种类。

+ Browser进程：浏览器的主进程（负责协调和主要控制），只有一个。主要负责：
  + 负责浏览器界面显示，与用户交互。如前进，后退。
  + 负责各个页面的管理，创建和销毁其他进程。
  + 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上。
  + 网络资源的管理
+ GPU进程：最多只有一个，用于3D绘制
+ 浏览器渲染进程（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要负责：页面渲染，脚本执行，事件处理等。
+ 第三方插件进程，每种类型的插件对应一个进程，仅当使用该插件时才创建

> 强调一下：在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）

之所以将浏览器设计成多进程，是因为，如果设计成单线程，那么某个Tab页面崩溃了，就影响了整个浏览器，插件也是同理。虽然多进程消耗了更多的资源，但是利用了计算机多核的优势。

## 渲染进程

> 浏览器的渲染进程是多线程的

+ GUI线程：负责渲染浏览器界面，解析HTML&CSS，构建DOM树和渲染树（RenderObject树），布局和绘制；当界面需要重绘或由于某种操作引发回流时，该线程就会执行；注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎线程在执行的时候，GUI线程会被挂起，GUI更新会保存到一个队列中，等到JS引擎空闲时立即执行
+ JS引擎线程：JS内核负责解析Javascript脚本程序，解析之后执行；JS引擎一直等待着任务对立中任务的到来，一个渲染进程中有且只有一个JS引擎线程。
+ 事件触发线程：用来控制事件循环，JS引擎执行需要帮忙。当JS引擎的执行到事件触发时，事件触发线程会把事件的处理函数添加到待处理队列的对位。
+ 定时器触发器线程： 也就是处理定时计数器触发的线程。
+ 异步HTTP请求线程：在XMLHTTPRequest连接之后是通过浏览器新开一个线程请求，当检测到状态变更的时候，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。

## GUI渲染与JS引擎互斥

由于Javascript可以操作DOM的，如果在修改这些元素属性同时渲染界面，那么将导致渲染前后获得的元素数据不一致，所以，为了防止这种不可预期的结果，浏览器设置GUI渲染线程与JS引擎互斥。

对于JS引擎线程来说，如果其在进行大量的计算，就算此时GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。

 ## JS运行机制

### Eventloop

1. JS分为同步任务和异步任务
2. 同步任务都在主线程上执行，形成一个`执行栈`
3. 主线程之外，**事件触发线程**管理着一个`任务队列`，只要异步任务有了运行结果，就在`任务队列`之中放置一个事件。
4. 一旦`执行栈`中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取`任务队列`，将可运行的异步任务添加到可执行栈中，开始执行

主线程运行时会产生执行栈，栈中的代码调用某些api时，它们会在事件中添加各种事件的回调函数，当执行栈中的代码执行完毕，js引擎会去读取事件队列中的事件，然后去执行那些回调，然后如此往复循环。需要注意的是，总是要等待执行栈中的代码执行完毕后才会去读取事件队列中的事件。

对于`setTImeout`以及`setInterval`事件，触发的条件就是时间计算，而时间的计算是由定时器触发线程来计算的，当触发条件达到的时候，就将这个事件推入到事件队列当中。

### macrotask&microtask

macrotask：又叫宏任务，每次执行栈执行的代码就是一个宏任务，包括从事件队列中获取一个事件回调并放到执行栈中执行。

microtask：又叫微任务，当前task执行结束后立即执行的任务，也就是说，在某一个宏任务执行完之后，就会将它执行期间产生的所有微任务都执行完毕。

常见的宏任务包括：主代码块，setTimeout，setInterval

常见的微任务包括：Promise，process.nextTick

## 回流与重绘

我们前面说过了，浏览器使用流式布局模型，渲染进程中的GUI线程会把HTML解析成DOM，把CSS解析成CSSOM，两个OM结合成一个渲染树。在渲染树中，我们了解到了所有节点的样式，然后计算他们在页面的大小和位置，最后把节点绘制到页面上，由于浏览器的流式布局，所以对待渲染树的计算通常只需要遍历一次就可以完成。需要注意的是，回流必将引起重绘，重绘不一定会引起回流。回流比重绘的代价要高。

### 回流

当渲染树中某个节点发生改变的时候，浏览器重新渲染部分或全部文档，这就叫做回流。

导致回流的操作有： 

+ 页面首次渲染
+ 元素尺寸或位置发生改变
+ 元素内容的变化
+ 添加或者删除可见的DOM元素
+ 查询某些属性或调用某些方法：`clientWidth/clientHeight`,`offsetTop`等

### 重绘

页面中元素样式的改变并不影响它在文档流中的位置时，浏览器会将新样式重新赋给元素并重新绘制。比如：`color`，`background-color`等等。

### 避免方法

+ 避免使用table布局
+ 避免设置多层内联样式
+ 避免使用css表达式
+ 一次性重写style或者class属性
+ 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后把这个节点添加到文档中
+ 对具有负责动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素以及后续元素频繁回流

## 缓存

整个web开发过程中，缓存会用到很多层，浏览器缓存，DNS缓存，CDN缓存以及数据库里的分布式缓存等等。

这里我们只讨论浏览器缓存。

当浏览器请求一个网站的时候，会加载各种各样的资源，比如：HTML文档、图片、CSS和JS等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。通过开发者工具里面的网络信息，缓存的资源会被标记为`disk cache`或者`memory cache`，依旧是我们常说的本地磁盘读取和浏览器内存读取。

虽然浏览器缓存看似是浏览器的功能，其实是靠**服务器控制**的。准确地说，当浏览器请求了一个网页时，服务器发回的响应头中的部分字段指明了有关缓存的关键信息

通用首部：

| 字段名称          | 说明      |
| ------------- | ------- |
| Cache-Control | 控制缓存的行为 |

请求首部字段：

| 字段名称                | 说明               |
| ------------------- | ---------------- |
| If-Match            | 比较Etag是否一致       |
| If-None-Match       | 比较Etag是否不一致      |
| If-Modified-Since   | 比较资源更新的时间是否一致    |
| If-Unmodified-Since | 比较资源最后更新的时间是否不一致 |

响应首部字段：

| 字段名称 | 说明      |
| ---- | ------- |
| Etag | 资源的匹配信息 |

实体首部字段：

| 字段名称          | 说明                     |
| ------------- | ---------------------- |
| Expires       | http1.0 的遗留物，实体主体过期的时间 |
| Last-Modified | 资源的最后一次修改的时间           |

根据以上字段的不同，浏览器会使用不同策略，在浏览器中，缓存可分为强缓存和协商缓存。

### 缓存机制

+ 浏览器加载资源时，先根据这个资源的一些http header 判断它是否命中强缓存，如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。
+ 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器一句资源的另外一些http header验证这个资源是否命中协商缓存，如果命中，服务器会将这个请求返回，当时刽返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源。
+ 如果协商缓存没有命中，浏览器直接从服务器加载资源数据。

### 强缓存

通过首部的Expires和Cache-Control两个响应头实现的，

